<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç« èŠ‚çŸ¥è¯†å›¾è°±æŸ¥è¯¢</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        /* é¡¶éƒ¨å¯¼èˆª */
        .header {
            padding: 15px 20px;
            background: rgba(20, 20, 40, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .header h1 {
            font-size: 1.3rem;
            color: #fff;
        }
        
        .header a {
            color: #3498db;
            text-decoration: none;
            font-size: 0.9rem;
        }
        
        .header .controls {
            display: flex;
            gap: 15px;
            margin-left: auto;
            align-items: center;
        }
        
        .header select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 0.9rem;
            min-width: 150px;
        }
        
        .header select option {
            background: #1a1a2e;
        }
        
        .header .status {
            font-size: 0.85rem;
            color: #888;
        }
        
        .header .status.connected {
            color: #2ecc71;
        }
        
        .header .status.error {
            color: #e74c3c;
        }
        
        /* ä¸»ä½“å¸ƒå±€ */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }
        
        /* å·¦ä¾§ç« èŠ‚åˆ—è¡¨ */
        .chapter-panel {
            width: 280px;
            background: rgba(20, 20, 40, 0.95);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .chapter-panel-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .chapter-panel-header h3 {
            font-size: 0.95rem;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        .chapter-filter {
            width: 100%;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 0.85rem;
        }
        
        .chapter-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .chapter-item {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.02);
        }
        
        .chapter-item:hover {
            background: rgba(52, 152, 219, 0.1);
            border-left-color: #3498db;
        }
        
        .chapter-item.selected {
            background: rgba(52, 152, 219, 0.2);
            border-left-color: #3498db;
        }
        
        .chapter-item.queried {
            background: rgba(46, 204, 113, 0.1);
            border-left-color: #2ecc71;
        }
        
        .chapter-item .chapter-title {
            color: #fff;
            margin-bottom: 2px;
        }
        
        .chapter-item .chapter-meta {
            font-size: 0.75rem;
            color: #666;
        }
        
        .chapter-actions {
            padding: 10px 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
        }
        
        .chapter-actions button {
            flex: 1;
            padding: 8px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        
        .chapter-actions .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        
        .chapter-actions .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #21618c);
        }
        
        .chapter-actions .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        /* å³ä¾§å›¾è°±å±•ç¤ºåŒº */
        .graph-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .graph-panel-header {
            padding: 10px 15px;
            background: rgba(20, 20, 40, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .graph-panel-header h3 {
            font-size: 0.95rem;
            color: #aaa;
        }
        
        .view-toggle {
            display: flex;
            gap: 5px;
        }
        
        .view-toggle button {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent;
            color: #888;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .view-toggle button.active {
            background: rgba(52, 152, 219, 0.2);
            border-color: #3498db;
            color: #3498db;
        }
        
        /* åŒåˆ—ç½‘æ ¼å¸ƒå±€ */
        .graph-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .graph-grid.single-view {
            grid-template-columns: 1fr;
        }
        
        .graph-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 300px;
            transition: all 0.3s;
        }
        
        .graph-card:hover {
            border-color: rgba(52, 152, 219, 0.5);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .graph-card.expanded {
            position: fixed;
            top: 80px;
            left: 300px;
            right: 20px;
            bottom: 20px;
            z-index: 100;
            min-height: auto;
        }
        
        .graph-card-header {
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .graph-card-header .title {
            font-size: 0.95rem;
            color: #fff;
            font-weight: 500;
        }
        
        .graph-card-header .stats {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            color: #888;
        }
        
        .graph-card-header .close-btn {
            display: none;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px;
        }
        
        .graph-card.expanded .close-btn {
            display: block;
        }
        
        .graph-card-body {
            flex: 1;
            position: relative;
        }
        
        .graph-card-body svg {
            width: 100%;
            height: 100%;
        }
        
        .graph-card-footer {
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 8px;
        }
        
        .graph-card-footer button {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent;
            color: #888;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        
        .graph-card-footer button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        /* ç©ºçŠ¶æ€ */
        .empty-state {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px;
            color: #666;
        }
        
        .empty-state .icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .empty-state p {
            font-size: 0.95rem;
        }
        
        /* åŠ è½½çŠ¶æ€ */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #3498db;
            font-size: 0.9rem;
        }
        
        /* èŠ‚ç‚¹æ ·å¼ */
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }
        
        .node text {
            font-size: 9px;
            fill: #fff;
            pointer-events: none;
            text-shadow: 0 0 3px rgba(0,0,0,0.8);
        }
        
        .link {
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 1px;
        }
        
        /* é®ç½©å±‚ */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99;
        }
        
        .overlay.active {
            display: block;
        }

        /* Toastæç¤º */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 0.9rem;
            z-index: 1000;
            display: none;
        }
        
        .toast.show {
            display: block;
        }
        
        .toast.error {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .toast.success {
            background: rgba(46, 204, 113, 0.9);
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <header class="header">
        <h1>ğŸ” ç« èŠ‚çŸ¥è¯†å›¾è°±æŸ¥è¯¢</h1>
        <a href="index.html">â† è¿”å›é¦–é¡µ</a>
        <div class="controls">
            <select id="subject-select">
                <option value="">é€‰æ‹©å­¦ç§‘...</option>
            </select>
            <span id="api-status" class="status">âšª æ£€æŸ¥APIçŠ¶æ€...</span>
        </div>
    </header>
    
    <!-- ä¸»ä½“ -->
    <div class="main-container">
        <!-- å·¦ä¾§ç« èŠ‚åˆ—è¡¨ -->
        <aside class="chapter-panel">
            <div class="chapter-panel-header">
                <h3>ğŸ“š ç« èŠ‚åˆ—è¡¨</h3>
                <input type="text" class="chapter-filter" placeholder="æœç´¢ç« èŠ‚..." id="chapter-filter">
            </div>
            <div class="chapter-list" id="chapter-list">
                <div class="empty-state" style="padding: 40px 20px;">
                    <div class="icon">ğŸ“‹</div>
                    <p>è¯·å…ˆé€‰æ‹©å­¦ç§‘</p>
                </div>
            </div>
            <div class="chapter-actions">
                <button class="btn-primary" id="query-selected" disabled>æŸ¥è¯¢é€‰ä¸­ç« èŠ‚</button>
                <button class="btn-secondary" id="clear-all">æ¸…ç©º</button>
            </div>
        </aside>
        
        <!-- å³ä¾§å›¾è°±åŒº -->
        <main class="graph-panel">
            <div class="graph-panel-header">
                <h3>ğŸ“Š çŸ¥è¯†å­å›¾ <span id="graph-count">(0)</span></h3>
                <div class="view-toggle">
                    <button class="active" data-view="grid">åŒåˆ—è§†å›¾</button>
                    <button data-view="single">å•åˆ—è§†å›¾</button>
                </div>
            </div>
            <div class="graph-grid" id="graph-grid">
                <div class="empty-state">
                    <div class="icon">ğŸ”</div>
                    <p>é€‰æ‹©ç« èŠ‚å¹¶ç‚¹å‡»"æŸ¥è¯¢é€‰ä¸­ç« èŠ‚"æŸ¥çœ‹çŸ¥è¯†å­å›¾</p>
                </div>
            </div>
        </main>
    </div>
    
    <!-- é®ç½©å±‚ -->
    <div class="overlay" id="overlay"></div>
    
    <!-- Toastæç¤º -->
    <div class="toast" id="toast"></div>
    
    <script>
        // ========== é…ç½® ==========
        const API_BASE = 'http://localhost:8889/api';
        
        // å­¦ç§‘é…ç½®ï¼ˆå†…åµŒï¼Œä¸ä¾èµ–APIï¼‰
        const SUBJECTS = [
            { name: "é«˜ä¸­æ•°å­¦", icon: "ğŸ“", label: "GaoZhongShuXue", color: "#2ecc71" },
            { name: "é«˜ä¸­ç‰©ç†", icon: "âš›ï¸", label: "GaoZhongWuLi", color: "#3498db" },
            { name: "é«˜ä¸­åŒ–å­¦", icon: "âš—ï¸", label: "GaoZhongHuaXue", color: "#8e44ad" },
            { name: "é«˜ä¸­ç”Ÿç‰©", icon: "ğŸ§¬", label: "GaoZhongShengWu", color: "#27ae60" },
            { name: "é«˜ä¸­æ”¿æ²»", icon: "ğŸ›ï¸", label: "GaoZhongZhengZhi", color: "#c0392b" },
            { name: "é«˜ä¸­åœ°ç†", icon: "ğŸ—ºï¸", label: "GaoZhongDiLi", color: "#3498db" },
            { name: "é«˜ä¸­å†å²", icon: "ğŸ›ï¸", label: "GaoZhongLiShi", color: "#6c5ce7" },
            { name: "ä¹‰æ•™æ•°å­¦", icon: "ğŸ“", label: "YiJiaoShuXue", color: "#f39c12" },
            { name: "ä¹‰æ•™ç‰©ç†", icon: "âš¡", label: "YiJiaoWuLi", color: "#e74c3c" },
            { name: "ä¹‰æ•™åŒ–å­¦", icon: "ğŸ§ª", label: "YiJiaoHuaXue", color: "#9b59b6" },
            { name: "ä¹‰æ•™åœ°ç†", icon: "ğŸŒ", label: "YiJiaoDiLi", color: "#1abc9c" },
            { name: "åˆä¸­åœ°ç†", icon: "ğŸ—ºï¸", label: "ChuZhongDiLi", color: "#16a085" },
            { name: "ä¹‰æ•™ç”Ÿç‰©", icon: "ğŸŒ±", label: "YiJiaoShengWu", color: "#16a085" },
            { name: "ä¹‰æ•™é“æ³•", icon: "âš–ï¸", label: "YiJiaoDaoFa", color: "#d63031" },
            { name: "ä¹‰æ•™å†å²", icon: "ğŸ“œ", label: "YiJiaoLiShi", color: "#8e44ad" }
        ];
        
        // ========== çŠ¶æ€ ==========
        let currentSubject = null;
        let chapters = [];
        let selectedChapters = new Set();
        let queriedGraphs = new Map(); // chapterId -> graphData
        let apiAvailable = false;
        
        // ========== å·¥å…·å‡½æ•° ==========
        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show ' + type;
            setTimeout(() => {
                toast.className = 'toast';
            }, 3000);
        }
        
        function updateApiStatus(available, message) {
            const status = document.getElementById('api-status');
            apiAvailable = available;
            if (available) {
                status.className = 'status connected';
                status.textContent = 'ğŸŸ¢ APIå·²è¿æ¥';
            } else {
                status.className = 'status error';
                status.textContent = 'ğŸ”´ ' + message;
            }
        }
        
        // ========== åˆå§‹åŒ– ==========
        function init() {
            // åˆå§‹åŒ–å­¦ç§‘ä¸‹æ‹‰æ¡†
            const subjectSelect = document.getElementById('subject-select');
            SUBJECTS.forEach(subject => {
                const option = document.createElement('option');
                option.value = subject.name;
                option.textContent = `${subject.icon} ${subject.name}`;
                subjectSelect.appendChild(option);
            });
            
            // æ£€æŸ¥APIçŠ¶æ€
            checkApiStatus();
            
            // ç»‘å®šäº‹ä»¶
            subjectSelect.addEventListener('change', onSubjectChange);
            document.getElementById('chapter-filter').addEventListener('input', onFilterChange);
            document.getElementById('query-selected').addEventListener('click', querySelectedChapters);
            document.getElementById('clear-all').addEventListener('click', clearAll);
            document.getElementById('overlay').addEventListener('click', closeExpanded);
            
            // è§†å›¾åˆ‡æ¢
            document.querySelectorAll('.view-toggle button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.view-toggle button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const grid = document.getElementById('graph-grid');
                    if (btn.dataset.view === 'single') {
                        grid.classList.add('single-view');
                    } else {
                        grid.classList.remove('single-view');
                    }
                });
            });
        }
        
        // æ£€æŸ¥APIçŠ¶æ€
        async function checkApiStatus() {
            try {
                const response = await fetch(`${API_BASE}/subjects`, { 
                    method: 'GET',
                    signal: AbortSignal.timeout(3000) 
                });
                if (response.ok) {
                    updateApiStatus(true, '');
                } else {
                    updateApiStatus(false, 'APIå“åº”é”™è¯¯');
                }
            } catch (error) {
                updateApiStatus(false, 'APIæœªå¯åŠ¨');
                console.log('APIæœªå¯åŠ¨ï¼Œè¯·è¿è¡Œ: python3 manage.py api');
            }
        }
        
        // å­¦ç§‘åˆ‡æ¢
        async function onSubjectChange(e) {
            const subjectName = e.target.value;
            if (!subjectName) {
                currentSubject = null;
                chapters = [];
                renderChapterList();
                return;
            }
            
            currentSubject = SUBJECTS.find(s => s.name === subjectName);
            
            if (!apiAvailable) {
                showToast('è¯·å…ˆå¯åŠ¨APIæœåŠ¡: python3 manage.py api', 'error');
                return;
            }
            
            // å…ˆè·å–èŠ‚ç‚¹ç±»å‹
            try {
                const typeResponse = await fetch(`${API_BASE}/node_types?subject=${encodeURIComponent(subjectName)}`);
                const typeData = await typeResponse.json();
                
                if (typeData.node_types && typeData.node_types.length > 0) {
                    console.log('èŠ‚ç‚¹ç±»å‹:', typeData.node_types);
                }
            } catch (error) {
                console.log('è·å–èŠ‚ç‚¹ç±»å‹å¤±è´¥:', error);
            }
            
            // åŠ è½½ç« èŠ‚
            try {
                const response = await fetch(`${API_BASE}/chapters?subject=${encodeURIComponent(subjectName)}`);
                const data = await response.json();
                
                if (data.error) {
                    showToast(data.error, 'error');
                    chapters = [];
                } else if (data.message) {
                    showToast(data.message, 'error');
                    chapters = [];
                } else {
                    chapters = data.chapters || [];
                    const nodeType = data.node_type || 'Chapter';
                    showToast(`å·²åŠ è½½ ${chapters.length} ä¸ª${nodeType}`, 'success');
                }
            } catch (error) {
                showToast('åŠ è½½ç« èŠ‚å¤±è´¥: ' + error.message, 'error');
                chapters = [];
            }
            
            selectedChapters.clear();
            renderChapterList();
            updateQueryButton();
        }
        
        // ç­›é€‰ç« èŠ‚
        function onFilterChange(e) {
            const keyword = e.target.value.toLowerCase();
            document.querySelectorAll('.chapter-item').forEach(item => {
                const title = item.querySelector('.chapter-title').textContent.toLowerCase();
                item.style.display = title.includes(keyword) ? '' : 'none';
            });
        }
        
        // æ¸²æŸ“ç« èŠ‚åˆ—è¡¨
        function renderChapterList() {
            const container = document.getElementById('chapter-list');
            
            if (chapters.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding: 40px 20px;">
                        <div class="icon">ğŸ“‹</div>
                        <p>${currentSubject ? 'æš‚æ— ç« èŠ‚æ•°æ®' : 'è¯·å…ˆé€‰æ‹©å­¦ç§‘'}</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = chapters.map((chapter, index) => `
                <div class="chapter-item ${selectedChapters.has(chapter.id) ? 'selected' : ''} ${queriedGraphs.has(chapter.id) ? 'queried' : ''}" 
                     data-id="${chapter.id}" data-index="${index}">
                    <div class="chapter-title">${chapter.title}</div>
                    <div class="chapter-meta">${queriedGraphs.has(chapter.id) ? 'âœ“ å·²æŸ¥è¯¢' : ''}</div>
                </div>
            `).join('');
            
            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            container.querySelectorAll('.chapter-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = item.dataset.id;
                    if (selectedChapters.has(id)) {
                        selectedChapters.delete(id);
                        item.classList.remove('selected');
                    } else {
                        selectedChapters.add(id);
                        item.classList.add('selected');
                    }
                    updateQueryButton();
                });
            });
        }
        
        // æ›´æ–°æŸ¥è¯¢æŒ‰é’®çŠ¶æ€
        function updateQueryButton() {
            const btn = document.getElementById('query-selected');
            btn.disabled = selectedChapters.size === 0 || !apiAvailable;
            btn.textContent = selectedChapters.size > 0 
                ? `æŸ¥è¯¢é€‰ä¸­ç« èŠ‚ (${selectedChapters.size})` 
                : 'æŸ¥è¯¢é€‰ä¸­ç« èŠ‚';
        }
        
        // æŸ¥è¯¢é€‰ä¸­çš„ç« èŠ‚
        async function querySelectedChapters() {
            if (selectedChapters.size === 0 || !currentSubject) return;
            
            const chaptersToQuery = Array.from(selectedChapters);
            
            for (const chapterId of chaptersToQuery) {
                if (!queriedGraphs.has(chapterId)) {
                    await queryChapterSubgraph(chapterId);
                }
            }
            
            renderChapterList();
            renderGraphGrid();
        }
        
        // æŸ¥è¯¢å•ä¸ªç« èŠ‚å­å›¾
        async function queryChapterSubgraph(chapterId) {
            const chapter = chapters.find(c => c.id === chapterId);
            if (!chapter) return;
            
            try {
                const response = await fetch(
                    `${API_BASE}/query/subgraph?subject=${encodeURIComponent(currentSubject.name)}&chapter_id=${encodeURIComponent(chapterId)}`
                );
                const data = await response.json();
                
                if (data.error) {
                    showToast(`${chapter.title}: ${data.error}`, 'error');
                    return;
                }
                
                queriedGraphs.set(chapterId, {
                    chapter: chapter,
                    data: data,
                    subject: currentSubject
                });
                
            } catch (error) {
                showToast(`æŸ¥è¯¢å¤±è´¥: ${error.message}`, 'error');
            }
        }
        
        // æ¸²æŸ“å›¾è°±ç½‘æ ¼
        function renderGraphGrid() {
            const container = document.getElementById('graph-grid');
            document.getElementById('graph-count').textContent = `(${queriedGraphs.size})`;
            
            if (queriedGraphs.size === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">ğŸ”</div>
                        <p>é€‰æ‹©ç« èŠ‚å¹¶ç‚¹å‡»"æŸ¥è¯¢é€‰ä¸­ç« èŠ‚"æŸ¥çœ‹çŸ¥è¯†å­å›¾</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            queriedGraphs.forEach((graphInfo, chapterId) => {
                const card = createGraphCard(chapterId, graphInfo);
                container.appendChild(card);
            });
        }
        
        // åˆ›å»ºå›¾è°±å¡ç‰‡
        function createGraphCard(chapterId, graphInfo) {
            const card = document.createElement('div');
            card.className = 'graph-card';
            card.dataset.id = chapterId;
            
            const { chapter, data, subject } = graphInfo;
            
            card.innerHTML = `
                <div class="graph-card-header">
                    <span class="title">${chapter.title}</span>
                    <div class="stats">
                        <span>ğŸ“Š ${data.node_count}èŠ‚ç‚¹</span>
                        <span>ğŸ”— ${data.relationship_count}å…³ç³»</span>
                    </div>
                    <button class="close-btn" onclick="closeCard('${chapterId}')">&times;</button>
                </div>
                <div class="graph-card-body" id="graph-body-${chapterId}">
                </div>
                <div class="graph-card-footer">
                    <button onclick="expandCard('${chapterId}')">ğŸ” æ”¾å¤§</button>
                    <button onclick="removeCard('${chapterId}')">âœ• ç§»é™¤</button>
                    <button onclick="queryLongestPath('${chapterId}')">ğŸ“ æœ€é•¿è·¯å¾„</button>
                </div>
            `;
            
            // æ¸²æŸ“å›¾è°±
            setTimeout(() => {
                renderMiniGraph(chapterId, data, subject);
            }, 100);
            
            return card;
        }
        
        // æ¸²æŸ“è¿·ä½ å›¾è°±
        function renderMiniGraph(chapterId, data, subject) {
            const container = document.getElementById(`graph-body-${chapterId}`);
            if (!container) return;
            
            const width = container.clientWidth || 300;
            const height = container.clientHeight || 200;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            const g = svg.append('g');
            
            // æ·»åŠ ç¼©æ”¾
            const zoom = d3.zoom()
                .scaleExtent([0.2, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            svg.call(zoom);
            
            // å‡†å¤‡æ•°æ®
            const nodes = data.nodes.map(n => ({
                ...n,
                id: n.id,
                name: n.title || n.name || n.identifier || 'æœªå‘½å'
            }));
            
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            const links = data.relationships
                .filter(r => nodeMap.has(r.start) && nodeMap.has(r.end))
                .map(r => ({
                    source: r.start,
                    target: r.end,
                    type: r.type
                }));
            
            // åŠ›å¯¼å‘å›¾
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(40))
                .force('charge', d3.forceManyBody().strength(-80))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(15));
            
            // ç»˜åˆ¶è¿çº¿
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .attr('class', 'link');
            
            // ç»˜åˆ¶èŠ‚ç‚¹
            const node = g.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', (event) => {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        event.subject.fx = event.subject.x;
                        event.subject.fy = event.subject.y;
                    })
                    .on('drag', (event) => {
                        event.subject.fx = event.x;
                        event.subject.fy = event.y;
                    })
                    .on('end', (event) => {
                        if (!event.active) simulation.alphaTarget(0);
                        event.subject.fx = null;
                        event.subject.fy = null;
                    }));
            
            node.append('circle')
                .attr('r', d => Math.min(8, 4 + (d.name.length / 5)))
                .attr('fill', subject.color);
            
            node.append('title')
                .text(d => d.name);
            
            // æ›´æ–°ä½ç½®
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // 50å¸§ååœæ­¢
            setTimeout(() => simulation.stop(), 2000);
        }
        
        // æ”¾å¤§å¡ç‰‡
        function expandCard(chapterId) {
            const card = document.querySelector(`.graph-card[data-id="${chapterId}"]`);
            if (card) {
                card.classList.add('expanded');
                document.getElementById('overlay').classList.add('active');
                
                // é‡æ–°æ¸²æŸ“æ›´å¤§çš„å›¾
                const graphInfo = queriedGraphs.get(chapterId);
                if (graphInfo) {
                    const container = document.getElementById(`graph-body-${chapterId}`);
                    container.innerHTML = '';
                    setTimeout(() => {
                        renderMiniGraph(chapterId, graphInfo.data, graphInfo.subject);
                    }, 100);
                }
            }
        }
        
        // å…³é—­æ”¾å¤§
        function closeExpanded() {
            document.querySelectorAll('.graph-card.expanded').forEach(card => {
                card.classList.remove('expanded');
            });
            document.getElementById('overlay').classList.remove('active');
        }
        
        function closeCard(chapterId) {
            closeExpanded();
        }
        
        // ç§»é™¤å¡ç‰‡
        function removeCard(chapterId) {
            queriedGraphs.delete(chapterId);
            selectedChapters.delete(chapterId);
            renderChapterList();
            renderGraphGrid();
        }
        
        // æ¸…ç©ºæ‰€æœ‰
        function clearAll() {
            queriedGraphs.clear();
            selectedChapters.clear();
            renderChapterList();
            renderGraphGrid();
            updateQueryButton();
        }
        
        // æŸ¥è¯¢æœ€é•¿è·¯å¾„
        async function queryLongestPath(chapterId) {
            if (!currentSubject) return;
            
            const chapter = chapters.find(c => c.id === chapterId);
            
            try {
                const response = await fetch(
                    `${API_BASE}/query/longest_path?subject=${encodeURIComponent(currentSubject.name)}&chapter_id=${encodeURIComponent(chapterId)}`
                );
                const data = await response.json();
                
                if (data.error) {
                    showToast(data.error, 'error');
                    return;
                }
                
                if (data.paths && data.paths.length > 0) {
                    const longestPath = data.paths[0];
                    const pathStr = longestPath.nodes.map(n => n.title).join(' â†’ ');
                    showToast(`æœ€é•¿è·¯å¾„(${longestPath.length}æ­¥): ${pathStr.substring(0, 100)}...`, 'success');
                } else {
                    showToast('æœªæ‰¾åˆ°è·¯å¾„', 'error');
                }
                
            } catch (error) {
                showToast('æŸ¥è¯¢å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // å¯åŠ¨
        init();
    </script>
</body>
</html>
